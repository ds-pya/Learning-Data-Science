import android.graphics.Bitmap
import android.graphics.Rect
import android.os.Build
import android.os.Environment
import android.view.accessibility.AccessibilityNodeInfo
import java.io.File
import java.io.FileOutputStream
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

data class SavedStatePaths(
    val dirPath: String,
    val screenshotPath: String?,
    val layoutDumpPath: String?,
    val totalTextPath: String?
)

/**
 * 저장 규칙:
 * - <app>/files/Download/contextlens/yyyyMMdd_HHmmss_SSS/
 *   - screenshot.jpg (downscale + jpeg)
 *   - layoutdump.txt
 *   - totaltext.txt
 */
private fun saveStateToDownloadsContextLens(
    eventTimeMs: Long,
    packageName: String,
    // 스크린샷은 외부에서 캡쳐해 bitmap으로 넘기거나, null이면 스킵
    screenshotBitmap: Bitmap?,
    // root는 rootInActiveWindow를 넘겨주세요(서비스 내부에서만 가능)
    root: AccessibilityNodeInfo?
): SavedStatePaths {
    val tsFolder = SimpleDateFormat("yyyyMMdd_HHmmss_SSS", Locale.US).format(Date(eventTimeMs))

    val baseDir = File(
        applicationContext.getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS),
        "contextlens"
    )
    val runDir = File(baseDir, tsFolder).apply { mkdirs() }

    // (1) layoutdump
    val layoutDumpPath = root?.let {
        val layoutDump = buildLayoutDump(it)
        writeText(File(runDir, "layoutdump.txt"), layoutDump)
    }

    // (2) totaltext
    val totalTextPath = root?.let {
        val totalText = extractTexts(it).distinct().joinToString("\n")
        writeText(File(runDir, "totaltext.txt"), totalText)
    }

    // (3) screenshot (용량 고려: 리사이즈 + JPEG)
    val screenshotPath = screenshotBitmap?.let { bmp ->
        val resized = downscaleBitmap(bmp, maxLongSide = 1080)  // 필요 시 720/1440 등 조절
        val outFile = File(runDir, "screenshot.jpg")
        writeJpeg(outFile, resized, quality = 80)              // 70~85 선 추천
    }

    return SavedStatePaths(
        dirPath = runDir.absolutePath,
        screenshotPath = screenshotPath,
        layoutDumpPath = layoutDumpPath,
        totalTextPath = totalTextPath
    )
}

/* -----------------------------
   Helpers: write files
------------------------------ */

private fun writeText(file: File, text: String): String? {
    return try {
        file.writeText(text)
        file.absolutePath
    } catch (_: Throwable) {
        null
    }
}

private fun writeJpeg(file: File, bitmap: Bitmap, quality: Int): String? {
    return try {
        FileOutputStream(file).use { fos ->
            bitmap.compress(Bitmap.CompressFormat.JPEG, quality.coerceIn(0, 100), fos)
        }
        file.absolutePath
    } catch (_: Throwable) {
        null
    }
}

/* -----------------------------
   Helpers: downscale bitmap
------------------------------ */

private fun downscaleBitmap(src: Bitmap, maxLongSide: Int): Bitmap {
    val w = src.width
    val h = src.height
    val longSide = maxOf(w, h)
    if (longSide <= maxLongSide) return src

    val scale = maxLongSide.toFloat() / longSide.toFloat()
    val nw = (w * scale).toInt().coerceAtLeast(1)
    val nh = (h * scale).toInt().coerceAtLeast(1)
    return Bitmap.createScaledBitmap(src, nw, nh, true)
}

/* -----------------------------
   (1) Layout dump (hierarchical)
------------------------------ */

private fun buildLayoutDump(root: AccessibilityNodeInfo): String {
    val sb = StringBuilder(16_384)

    fun rectStr(node: AccessibilityNodeInfo): String {
        val r = Rect()
        node.getBoundsInScreen(r)
        return "${r.left},${r.top},${r.right},${r.bottom}"
    }

    fun nodeLabel(node: AccessibilityNodeInfo): String {
        val cls = node.className?.toString() ?: "null"
        val vid = node.viewIdResourceName ?: "-"
        val txt = node.text?.toString()?.trim()?.takeIf { it.isNotEmpty() }?.let { truncate(it, 40) } ?: "-"
        val cd = node.contentDescription?.toString()?.trim()?.takeIf { it.isNotEmpty() }?.let { truncate(it, 40) } ?: "-"
        return "cls=$cls vid=$vid txt=$txt cd=$cd b=${rectStr(node)} c=${node.isClickable} s=${node.isScrollable} e=${node.isEditable}"
    }

    fun dfs(node: AccessibilityNodeInfo, depth: Int) {
        repeat(depth) { sb.append("  ") }
        sb.appendLine(nodeLabel(node))
        for (i in 0 until node.childCount) {
            node.getChild(i)?.let { child ->
                dfs(child, depth + 1)
                child.recycle()
            }
        }
    }

    dfs(root, 0)
    return sb.toString()
}

/* -----------------------------
   (2) Text extraction (DFS)
------------------------------ */

private fun extractTexts(root: AccessibilityNodeInfo): List<String> {
    val out = ArrayList<String>(256)

    fun addIfNotBlank(s: CharSequence?) {
        val v = s?.toString()?.trim()
        if (!v.isNullOrEmpty()) out.add(v)
    }

    fun dfs(node: AccessibilityNodeInfo) {
        addIfNotBlank(node.text)
        addIfNotBlank(node.contentDescription)
        if (Build.VERSION.SDK_INT >= 26) addIfNotBlank(node.hintText)

        for (i in 0 until node.childCount) {
            node.getChild(i)?.let { child ->
                dfs(child)
                child.recycle()
            }
        }
    }

    dfs(root)
    return out
}

private fun truncate(s: String, max: Int): String =
    if (s.length <= max) s else s.substring(0, max) + "…"