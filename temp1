fun extractNamedEntities(
    decodedScore: IntArray, // 예: [0, 1, 2, 0, 3]
    attentionMask: IntArray, // 128
    specialTokensMask: IntArray, // 128
    offsets: List<Pair<Int, Int>>, // 128
    text: String
): List<Pair<String, String>> {

    // 라벨 인덱스를 BIO 라벨로 변환하는 리스트 (0~8)
    val labelMap = listOf(
        "O", "B-PER", "I-PER", "B-ORG", "I-ORG",
        "B-LOC", "I-LOC", "B-MISC", "I-MISC"
    )

    val result = mutableListOf<Pair<String, String>>()

    // 실제 라벨이 적용된 토큰 인덱스만 뽑기
    val realTokenIndices = (0 until attentionMask.size).filter { 
        attentionMask[it] == 1 && specialTokensMask[it] == 0 
    }

    var currentEntity: StringBuilder? = null
    var currentType: String? = null
    var currentStart: Int? = null
    var previousLabel = "O"

    for ((i, tokenIdx) in realTokenIndices.withIndex()) {
        val labelIdx = decodedScore[i]
        val label = labelMap[labelIdx]
        val (start, end) = offsets[tokenIdx]

        if (label == "O" || start >= end) {
            // 엔티티 종료 처리
            if (currentEntity != null && currentType != null && currentStart != null) {
                result.add(currentType to text.substring(currentStart, start))
                currentEntity = null
                currentType = null
                currentStart = null
            }
            previousLabel = "O"
            continue
        }

        val (tag, entityType) = label.split("-")

        when (tag) {
            "B" -> {
                // 기존 엔티티 종료 후 새로 시작
                if (currentEntity != null && currentType != null && currentStart != null) {
                    result.add(currentType to currentEntity.toString())
                }
                currentEntity = StringBuilder(text.substring(start, end))
                currentType = entityType
                currentStart = start
            }

            "I" -> {
                if (currentEntity != null && currentType == entityType) {
                    currentEntity.append(text.substring(start, end))
                } else {
                    // B 없이 잘못 시작된 I → 새 엔티티로 취급
                    currentEntity = StringBuilder(text.substring(start, end))
                    currentType = entityType
                    currentStart = start
                }
            }
        }

        previousLabel = label
    }

    // 루프 종료 후 마지막 엔티티 추가
    if (currentEntity != null && currentType != null && currentStart != null) {
        result.add(currentType to currentEntity.toString())
    }

    return result
}