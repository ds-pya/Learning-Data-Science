data class A11yTextItem(
    val packageName: String?,
    val className: String?,
    val viewId: String?,
    val text: String?,
    val contentDesc: String?,
    val hintText: String?,
    val bounds: String,
    val editable: Boolean,
    val clickable: Boolean,
    val scrollable: Boolean
)

fun dumpTextsFromRoot(root: AccessibilityNodeInfo?, pkg: CharSequence?): List<A11yTextItem> {
    if (root == null) return emptyList()
    val out = ArrayList<A11yTextItem>(256)

    fun rectToString(node: AccessibilityNodeInfo): String {
        val r = android.graphics.Rect()
        node.getBoundsInScreen(r)
        return "${r.left},${r.top},${r.right},${r.bottom}"
    }

    fun dfs(node: AccessibilityNodeInfo) {
        val text = node.text?.toString()?.takeIf { it.isNotBlank() }
        val cd = node.contentDescription?.toString()?.takeIf { it.isNotBlank() }
        val hint = try {
            node.hintText?.toString()?.takeIf { it.isNotBlank() }
        } catch (e: Throwable) { null }

        // “텍스트 후보가 하나라도 있으면” 기록 (원하면 조건 더 빡세게)
        if (text != null || cd != null || hint != null) {
            out.add(
                A11yTextItem(
                    packageName = pkg?.toString(),
                    className = node.className?.toString(),
                    viewId = node.viewIdResourceName,
                    text = text,
                    contentDesc = cd,
                    hintText = hint,
                    bounds = rectToString(node),
                    editable = node.isEditable,
                    clickable = node.isClickable,
                    scrollable = node.isScrollable
                )
            )
        }

        for (i in 0 until node.childCount) {
            node.getChild(i)?.let { child ->
                dfs(child)
                child.recycle()
            }
        }
    }

    dfs(root)
    return out
}