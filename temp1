data class Interest(val topic: String, val v1: Double, val v2: Double)

class ScorePyramidFragment : Fragment() {

    // TODO: 실제 소스에서 채워 넣으세요.
    private fun scoreV1(): Map<String, Double> = mapOf("music" to 0.84, "game" to 0.73, "soccer" to 0.41)
    private fun scoreV2(): Map<String, Double> = mapOf("music" to 3.2,  "game" to 1.1,  "soccer" to 2.0)

    override fun onCreateView(i: LayoutInflater, c: ViewGroup?, s: Bundle?): View {
        val root = LinearLayout(requireContext()).apply { orientation = LinearLayout.VERTICAL }
        val btn = Button(requireContext()).apply { text = "Execute" }
        val tv  = TextView(requireContext()).apply {
            typeface = Typeface.MONOSPACE; textSize = 13f
            setPadding(24, 24, 24, 24)
        }
        root.addView(btn); root.addView(ScrollView(requireContext()).apply { addView(tv) })

        fun render() {
            // width 확정 뒤 렌더
            tv.post {
                val r1 = scoreV1(); val r2 = scoreV2()
                val rows = r1.entries.map { (t, v) -> Interest(t, v, r2[t] ?: 0.0) }
                    .sortedByDescending { it.v1 }
                tv.text = buildPyramidString(tv.width - tv.paddingLeft - tv.paddingRight, tv.paint, rows)
            }
        }
        btn.setOnClickListener { render() }
        return root
    }
}

/** 인구피라미드 스타일 문자열(좌: v1, 우: v2). 좌우 독립 스케일, 바 양끝 숫자 표시 */
fun buildPyramidString(
    textWidthPx: Int,
    paint: TextPaint,
    records: List<Interest>,
    sep: String = " │ ",
    leftChar: Char = '█',     // tqdm 느낌의 블록
    rightChar: Char = '█',
    numCols: Int = 6          // 바 양끝 숫자 고정폭
): String {
    val charW = paint.measureText("M").coerceAtLeast(1f)
    val totalCols = (textWidthPx / charW).toInt().coerceAtLeast(48)

    val topicCols = minOf(maxOf(records.maxOfOrNull { it.topic.length } ?: 8, 8), 24)
    val sepCols = sep.length * 2
    val sideCols = ((totalCols - topicCols - sepCols - (numCols * 2)).coerceAtLeast(10)) / 2
    val leftCols = sideCols; val rightCols = sideCols

    val maxL = records.maxOfOrNull { it.v1 }?.takeIf { it > 0 } ?: 1.0
    val maxR = records.maxOfOrNull { it.v2 }?.takeIf { it > 0 } ?: 1.0

    fun f(v: Double) = "%.${if (v < 10) 2 else 1}f".format(Locale.US, v)
    fun tFit(t: String) = if (t.length <= topicCols) t.padEnd(topicCols) else t.take(topicCols - 1) + "…"

    fun leftBar(v: Double): String {
        val len = (v / maxL * leftCols).roundToInt().coerceIn(0, leftCols)
        val num = f(v).padStart(numCols)
        return num + " " + " ".repeat(leftCols - len) + leftChar.toString().repeat(len)
    }
    fun rightBar(v: Double): String {
        val len = (v / maxR * rightCols).roundToInt().coerceIn(0, rightCols)
        val num = f(v).padEnd(numCols)
        return rightChar.toString().repeat(len) + " ".repeat(rightCols - len) + " " + num
    }

    return buildString {
        appendLine("======== score ========")
        appendLine(
            " ".repeat(numCols - 2) + "v1" + " ".repeat(leftCols + 1) + sep +
            "topic".padEnd(topicCols) + sep +
            " ".repeat(rightCols + 1) + "v2"
        )
        records.forEach { r ->
            appendLine("${leftBar(r.v1)}$sep${tFit(r.topic)}$sep${rightBar(r.v2)}")
        }
    }
}