fun buildKeywordSuggestInputText(
    stms: List<StmSuggestionDto>,
    packageName: String,
    stmLimit: Int = 5,
    fourwPerStmLimit: Int = 5,
    filteredPerFourwLimit: Int = 3,
    maxChars: Int = 6000
): String {
    val b = StringBuilder()
    b.appendLine("TARGET_APP: $packageName")
    b.appendLine("RECENT_STM (latest first):")

    stms.take(stmLimit).forEach { s ->
        b.appendLine("[stm_id=${s.stmId}] summary=${(s.summary ?: "").take(200)}")
        s.fourws.take(fourwPerStmLimit).forEach { f ->
            val picked = f.filtered
                .asSequence()
                .map { it.trim() }
                .filter { it.length >= 2 }
                .distinct()
                .take(filteredPerFourwLimit)
                .toList()

            if (picked.isNotEmpty()) {
                b.appendLine("  - [fourw_id=${f.fourwId}] filtered:")
                picked.forEach { line -> b.appendLine("      * ${line.take(160)}") }
            }
        }
    }

    val out = b.toString()
    return if (out.length <= maxChars) out else out.take(maxChars)
}

fun buildKeywordSuggestPrompt(packageName: String): String {
    return """
You are generating search/query keyword suggestions for a user who is about to type in an input box.
The target app package is: $packageName.

Given recent short-term memory (STM) summaries and filtered snippets from recent screens, return 5 keyword suggestions ranked from best to worst.

Rules:
- Suggestions must be short Korean phrases (2~12 chars typical), not full sentences.
- Avoid duplicates and near-duplicates.
- Do NOT include numbering or extra text.
- Output MUST be a JSON array of strings only. Example: ["키워드1","키워드2","키워드3","키워드4","키워드5"]
If you cannot infer, output an empty JSON array: []
""".trim()
}

fun refineKeywordSuggestOutput(raw: String?): List<String>? {
    val s = raw?.trim().orEmpty()
    if (s.isEmpty()) return null

    fun clean(list: List<String>): List<String>? {
        val out = list.asSequence()
            .map { it.trim().trim('"') }
            .map { it.replace("\u0000", "") }
            .filter { it.isNotBlank() }
            .filter { it.length in 1..40 }
            .distinct()
            .take(5)
            .toList()
        return out.ifEmpty { null }
    }

    fun tryJsonArray(str: String): List<String>? {
        return try {
            val arr = org.json.JSONArray(str)
            val list = buildList {
                for (i in 0 until arr.length()) add(arr.optString(i))
            }
            clean(list)
        } catch (_: Throwable) {
            null
        }
    }

    fun tryJsonObject(str: String): List<String>? {
        return try {
            val obj = org.json.JSONObject(str)
            val arr = obj.optJSONArray("keywords") ?: obj.optJSONArray("suggestions") ?: return null
            val list = buildList {
                for (i in 0 until arr.length()) add(arr.optString(i))
            }
            clean(list)
        } catch (_: Throwable) {
            null
        }
    }

    val jsonArray = tryJsonArray(s)
    if (jsonArray != null) return jsonArray

    val jsonObject = tryJsonObject(s)
    if (jsonObject != null) return jsonObject

    val fallback = s
        .lines()
        .map { it.trim().trimStart('-', '*', '•').trim() }
        .filter { it.isNotBlank() }
    return clean(fallback)
}