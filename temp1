data class FilteredEvent(
    val id: Long,
    val parentId: Long?,   // parentId가 없거나(null) 리스트에 없으면 root 후보
    val text: String
)

/**
 * 뒤죽박죽 섞인 (id, parentId, text) 노드들을
 * "indent로 hierarchy를 구별할 수 있는 텍스트"로 변환한다.
 *
 * 규칙:
 * 1) root/최상위 노드는 parentId가 null이거나, parentId가 리스트에 존재하지 않는 노드들
 * 2) 같은 depth(=같은 부모의 children)에서는 id 오름차순
 * 3) 순환(cycle) / 고아(orphan) / parent 미존재 등 비정상 케이스도 최대한 출력한다
 */
fun toIndentedHierarchyText(
    events: List<FilteredEvent>,
    indentUnit: String = "  ", // 2 spaces
    showIds: Boolean = true
): String {
    if (events.isEmpty()) return ""

    // id -> node
    val byId: Map<Long, FilteredEvent> = events.associateBy { it.id }

    // parentId -> children list (id 오름차순 정렬)
    val childrenByParent: Map<Long?, List<FilteredEvent>> =
        events.groupBy { it.parentId }
            .mapValues { (_, v) -> v.sortedBy { it.id } }

    // root 후보: parentId == null OR parentId가 리스트에 없음
    val roots: List<FilteredEvent> = events
        .filter { it.parentId == null || !byId.containsKey(it.parentId) }
        .sortedBy { it.id }

    // roots가 비었으면(전부 서로 parent로 물려있거나 cycle), 일단 id 가장 작은 것부터 시작
    val startNodes: List<FilteredEvent> =
        if (roots.isNotEmpty()) roots else events.sortedBy { it.id }.take(1)

    val sb = StringBuilder()
    val globallyPrinted = HashSet<Long>() // 정상 트리 출력에 성공한 노드들(중복 출력 방지)

    fun lineOf(node: FilteredEvent, depth: Int): String {
        val indent = indentUnit.repeat(depth.coerceAtLeast(0))
        val label = if (showIds) "[${node.id}] ${node.text}" else node.text
        return indent + label
    }

    fun dfs(node: FilteredEvent, depth: Int, path: MutableSet<Long>) {
        // cycle 감지: 현재 경로(path)에 이미 있으면 표시하고 종료
        if (!path.add(node.id)) {
            sb.append(indentUnit.repeat(depth))
                .append(if (showIds) "[${node.id}] " else "")
                .append("⟲ CYCLE -> ${node.text}")
                .append('\n')
            return
        }

        sb.append(lineOf(node, depth)).append('\n')
        globallyPrinted.add(node.id)

        val children = childrenByParent[node.id].orEmpty()
        for (child in children) {
            dfs(child, depth + 1, path)
        }

        path.remove(node.id)
    }

    // 1) root들부터 트리 출력
    for (root in startNodes) {
        dfs(root, 0, mutableSetOf())
    }

    // 2) 출력되지 못한 노드들(고아/분리 컴포넌트/잔여 cycle 등) 추가 출력
    val remaining = events
        .filter { it.id !in globallyPrinted }
        .sortedBy { it.id }

    if (remaining.isNotEmpty()) {
        sb.append("\n== Unattached / Remaining nodes ==\n")
        for (n in remaining) {
            // 남은 노드들도 각각을 root처럼 출력해 보되, 중복/사이클은 dfs에서 처리됨
            if (n.id !in globallyPrinted) {
                dfs(n, 0, mutableSetOf())
            }
        }
    }

    return sb.toString().trimEnd()
}