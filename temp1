// build.gradle
// implementation("org.jetbrains.kotlinx:kotlinx-coroutines-core:<latest>")
//
// ORT
// implementation("com.microsoft.onnxruntime:onnxruntime-android:<latest>")

import ai.onnxruntime.*
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.concurrent.ConcurrentHashMap

object OnnxRunner {

    // 1) Env는 프로세스 전역 싱글턴 (절대 close하지 말 것)
    private val env: OrtEnvironment by lazy { OrtEnvironment.getEnvironment() }

    // 2) 세션/뮤텍스 저장소
    private val sessions = ConcurrentHashMap<String, OrtSession>()
    private val mutexes  = ConcurrentHashMap<String, Mutex>()

    private fun mutexOf(name: String): Mutex =
        mutexes.computeIfAbsent(name) { Mutex() }

    // 3) 세션 생성/획득 (동일 name의 동시 생성 방지)
    suspend fun getOrCreateSession(
        name: String,
        modelBytes: ByteArray,
        options: OrtSession.SessionOptions? = null
    ): OrtSession {
        sessions[name]?.let { return it }
        val m = mutexOf(name)
        return m.withLock {
            sessions[name] ?: run {
                val s = if (options == null) env.createSession(modelBytes)
                        else env.createSession(modelBytes, options)
                sessions[name] = s
                s
            }
        }
    }

    // 4) 입력 텐서 유틸 (예시)
    fun createTensor(data: FloatArray, shape: LongArray): OnnxTensor =
        OnnxTensor.createTensor(env, data, shape)

    // 필요하면 다른 타입(임베딩, int64 등) 생성 유틸도 추가

    // 5) 안전 실행: 같은 name에 대해 run/close 상호배제
    //  - inputs: 생성한 OnnxTensor들 (호출자가 만든 것)
    //  - outputNames: 필요한 출력 이름들
    suspend fun runSentenceCls(
        name: String,
        inputs: Map<String, OnnxTensor>,
        outputNames: Set<String>
    ): FloatArray? {
        val m = mutexOf(name)
        var result: OrtSession.Result? = null
        try {
            return m.withLock {
                val session = sessions[name] ?: return@withLock null
                result = session.run(inputs, outputNames)

                // 예시: 첫 출력이 1xC float 로짓이라고 가정
                val logits = (result!!.get(0)?.value as? Array<FloatArray>) ?: return@withLock null
                logits[0].copyOf() // 복사본 반환 (Result 닫아도 안전)
            }
        } finally {
            // Result/입력 텐서는 반드시 닫기
            try { result?.close() } catch (_: Throwable) {}
            inputs.values.forEach { v -> try { v.close() } catch (_: Throwable) {} }
        }
    }

    // 6) 세션 하나 닫기 (run과 같은 Mutex로 보호)
    suspend fun close(name: String) {
        val m = mutexOf(name)
        m.withLock {
            sessions.remove(name)?.let { s ->
                try { s.close() } catch (_: Throwable) {}
            }
            // 필요 시: mutexes.remove(name) // 재생성 대비해 보통은 남겨둠
        }
    }

    // 7) 모두 닫기: 스냅샷 후 각 세션별 mutex로 순차 닫기
    suspend fun closeAll() {
        val names = sessions.keys.toList() // 스냅샷
        for (name in names) {
            val m = mutexOf(name)
            m.withLock {
                sessions.remove(name)?.let { s ->
                    try { s.close() } catch (_: Throwable) {}
                }
            }
        }
        // 필요 시 전체 뮤텍스 정리:
        // mutexes.clear()
    }
}