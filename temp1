class CRFDecoder(
    private val numLabels: Int,
    private val transitionMask: Array<FloatArray> // size: [numLabels][numLabels], 0 or -Inf
) {

    fun decode(emissions: Array<FloatArray>, attentionMask: IntArray): IntArray {
        val seqLen = emissions.size
        val dp = Array(seqLen) { FloatArray(numLabels) { Float.NEGATIVE_INFINITY } }
        val backpointers = Array(seqLen) { IntArray(numLabels) }

        // step 1: initialize with first token
        for (label in 0 until numLabels) {
            dp[0][label] = emissions[0][label]
        }

        // step 2: dynamic programming
        for (t in 1 until seqLen) {
            if (attentionMask[t] == 0) break

            for (curr in 0 until numLabels) {
                var maxScore = Float.NEGATIVE_INFINITY
                var bestPrev = 0
                for (prev in 0 until numLabels) {
                    val score = dp[t - 1][prev] + transitionMask[prev][curr]
                    if (score > maxScore) {
                        maxScore = score
                        bestPrev = prev
                    }
                }
                dp[t][curr] = maxScore + emissions[t][curr]
                backpointers[t][curr] = bestPrev
            }
        }

        // step 3: backtrace
        val result = IntArray(seqLen) { 0 }
        var bestLast = dp[attentionMask.indexOfLast { it == 1 }].withIndex().maxByOrNull { it.value }!!.index
        result[attentionMask.indexOfLast { it == 1 }] = bestLast

        for (t in (attentionMask.indexOfLast { it == 1 } - 1) downTo 0) {
            if (attentionMask[t] == 0) break
            bestLast = backpointers[t + 1][bestLast]
            result[t] = bestLast
        }

        return result
    }
}