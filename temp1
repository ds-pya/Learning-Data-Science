data class A11yNodeDTO(
    val id: Long?,
    val parentId: Long?,
    val className: String?,
    val text: String?,
    val contentDesc: String?,
    val viewId: String?,
    val bounds: Rect,
    val clickable: Boolean,
    val enabled: Boolean,
    val focusable: Boolean,
    val visible: Boolean,
    val children: List<Long>
)

fun dumpNodeTree(root: AccessibilityNodeInfo): List<A11yNodeDTO> {
    val result = mutableListOf<A11yNodeDTO>()
    var idCounter = 0L

    fun traverse(node: AccessibilityNodeInfo?, parentId: Long?) {
        if (node == null) return

        val myId = idCounter++
        val bounds = Rect().also { node.getBoundsInScreen(it) }

        val childIds = mutableListOf<Long>()

        val dto = A11yNodeDTO(
            id = myId,
            parentId = parentId,
            className = node.className?.toString(),
            text = node.text?.toString(),
            contentDesc = node.contentDescription?.toString(),
            viewId = node.viewIdResourceName,
            bounds = bounds,
            clickable = node.isClickable,
            enabled = node.isEnabled,
            focusable = node.isFocusable,
            visible = node.isVisibleToUser,
            children = childIds
        )

        result.add(dto)

        for (i in 0 until node.childCount) {
            val child = node.getChild(i)
            val childId = idCounter
            childIds.add(childId)
            traverse(child, myId)
            child?.recycle()
        }
    }

    traverse(root, null)
    return result
}

data class A11yWindowDTO(
    val id: Int,
    val type: Int,
    val title: String?,
    val bounds: Rect,
    val rootNodeId: Long?
)

fun dumpWindows(
    windows: List<AccessibilityWindowInfo>,
    nodeDump: Map<AccessibilityNodeInfo, Long>
): List<A11yWindowDTO> {
    return windows.map { w ->
        val bounds = Rect().also { w.getBoundsInScreen(it) }

        A11yWindowDTO(
            id = w.id,
            type = w.type,
            title = w.title?.toString(),
            bounds = bounds,
            rootNodeId = nodeDump[w.root]
        )
    }
}

import android.content.ContentValues
import android.content.Context
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

fun saveJsonToDownloads(
    context: Context,
    prefix: String,              // "~~~"
    packageName: String,
    jsonString: String
): String? {
    val safePkg = packageName.replace(Regex("""[^a-zA-Z0-9._-]"""), "_")
    val ts = SimpleDateFormat("yyyyMMdd_HHmmss_SSS", Locale.US).format(Date())
    val fileName = "${prefix}_${safePkg}_${ts}.json"

    // Android 10+ (Q+): MediaStore Downloads
    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
        val values = ContentValues().apply {
            put(MediaStore.Downloads.DISPLAY_NAME, fileName)
            put(MediaStore.Downloads.MIME_TYPE, "application/json")
            put(MediaStore.Downloads.IS_PENDING, 1)
        }

        val resolver = context.contentResolver
        val uri = resolver.insert(MediaStore.Downloads.EXTERNAL_CONTENT_URI, values) ?: return null

        resolver.openOutputStream(uri, "w")?.use { os ->
            os.write(jsonString.toByteArray(Charsets.UTF_8))
            os.flush()
        } ?: return null

        values.clear()
        values.put(MediaStore.Downloads.IS_PENDING, 0)
        resolver.update(uri, values, null, null)

        // 반환: 파일 식별 가능한 URI 문자열
        return uri.toString()
    }

    // Android 9 이하 fallback은 아래 섹션 참고
    return saveJsonToDownloadsLegacy(context, fileName, jsonString)
}