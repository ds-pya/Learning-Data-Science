data class StmFourwJoinRow(
    val stmId: Long,
    val stmCreatedAtMs: Long,
    val stmSummary: String?,
    val fourwId: Long?,
    val llmJson: String?,
    val vlmJson: String?,
)

data class FourwFilteredDto(
    val fourwId: Long,
    val filtered: List<String>,
)

data class StmSuggestionDto(
    val stmId: Long,
    val summary: String?,
    val fourws: List<FourwFilteredDto>,
)

@Dao
interface ShortTermMemoryDao {

    @Query(
        """
        WITH recent AS (
            SELECT id, createdAtMs, summary
            FROM short_term_memory
            ORDER BY createdAtMs DESC
            LIMIT :stmLimit
        )
        SELECT 
            recent.id AS stmId,
            recent.createdAtMs AS stmCreatedAtMs,
            recent.summary AS stmSummary,
            f.id AS fourwId,
            f.llmJson AS llmJson,
            f.vlmJson AS vlmJson
        FROM recent
        LEFT JOIN stm_fourw_link l ON l.stmId = recent.id
        LEFT JOIN fourw_log f ON f.id = l.fourwId
        ORDER BY recent.createdAtMs DESC, f.eventTimeMs DESC
        """
    )
    suspend fun listRecentStmFourwRows(stmLimit: Int = 5): List<StmFourwJoinRow>

    suspend fun listRecentStmSuggestions(stmLimit: Int = 5): List<StmSuggestionDto> {
        val rows = listRecentStmFourwRows(stmLimit)

        val order = ArrayList<Long>(stmLimit)
        val byStm = LinkedHashMap<Long, MutableList<StmFourwJoinRow>>()

        for (r in rows) {
            if (!byStm.containsKey(r.stmId)) {
                byStm[r.stmId] = mutableListOf()
                order.add(r.stmId)
            }
            byStm[r.stmId]!!.add(r)
        }

        return order.map { stmId ->
            val rs = byStm[stmId].orEmpty()
            val summary = rs.firstOrNull()?.stmSummary
            val fourws = rs.mapNotNull { r ->
                val fid = r.fourwId ?: return@mapNotNull null
                val filtered = extractFilteredPreferVlm(r.vlmJson, r.llmJson)
                FourwFilteredDto(fid, filtered)
            }
            StmSuggestionDto(stmId, summary, fourws)
        }
    }
}

private fun extractFilteredPreferVlm(vlmJson: String?, llmJson: String?): List<String> {
    val json = vlmJson ?: llmJson ?: return emptyList()
    return try {
        val obj = org.json.JSONObject(json)
        val arr = obj.optJSONArray("filtered") ?: return emptyList()
        buildList {
            for (i in 0 until arr.length()) {
                val s = arr.optString(i).trim()
                if (s.isNotEmpty()) add(s)
            }
        }
    } catch (_: Throwable) {
        emptyList()
    }
}