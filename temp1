fun viterbiDecode(
    emissions: Array<FloatArray>,        // [L][C]
    transitions: Array<FloatArray>,      // [C][C]
    mask: BooleanArray                   // [L]
): IntArray {
    val L = emissions.size
    val C = emissions[0].size
    val score = emissions[0].copyOf()
    val backpointers = mutableListOf<IntArray>()

    for (t in 1 until L) {
        val prevScore = FloatArray(C) { Float.NEGATIVE_INFINITY }
        val bp = IntArray(C)
        for (curr in 0 until C) {
            var maxScore = Float.NEGATIVE_INFINITY
            var argMax = 0
            for (prev in 0 until C) {
                val s = score[prev] + transitions[prev][curr]
                if (s > maxScore) {
                    maxScore = s
                    argMax = prev
                }
            }
            prevScore[curr] = maxScore + emissions[t][curr]
            bp[curr] = argMax
        }
        backpointers.add(bp)
        for (i in 0 until C) score[i] = prevScore[i]
    }

    // Backtrace
    val bestLast = score.indices.maxByOrNull { score[it] } ?: 0
    val path = mutableListOf(bestLast)
    var current = bestLast
    for (t in (L - 2) downTo 0) {
        current = backpointers[t][current]
        path.add(current)
    }

    path.reverse()
    return path.sliceArray(0 until mask.count { it })
}