data class Interest(val topic: String, val v1: Double, val v2: Double)

class ScorePyramidFragment : Fragment() {

    private val score1: Map<String, Double> = mapOf(/* topic to v1 */)
    private val score2: Map<String, Double> = mapOf(/* topic to v2 */)

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?
    ): View {
        val tv = TextView(requireContext()).apply {
            typeface = Typeface.MONOSPACE
            textSize = 13f
            setPadding(24, 24, 24, 24)
        }
        val root = FrameLayout(requireContext()).apply { addView(tv) }

        // 레이아웃 폭이 정해진 뒤에 문자열 생성
        tv.post {
            val records = score1.entries
                .map { (t, v) -> Interest(t, v, score2[t] ?: 0.0) }
                .sortedByDescending { it.v1 }

            tv.text = buildPyramidString(
                textWidthPx = tv.width - tv.paddingLeft - tv.paddingRight,
                paint = tv.paint,
                records = records
            )
        }
        return root
    }
}

/** 인구 피라미드 스타일 문자열 생성 */
fun buildPyramidString(
    textWidthPx: Int,
    paint: TextPaint,
    records: List<Interest>,
    sep: String = " │ "
): String {
    // 한 글자 폭(모노스페이스 전제)
    val charW = paint.measureText("M").coerceAtLeast(1f)
    val totalCols = (textWidthPx / charW).toInt().coerceAtLeast(40)

    // 헤더/분할: [leftBars] + sep + [topic] + sep + [rightBars]
    val topicCols = minOf(
        maxOf(records.maxOfOrNull { it.topic.length } ?: 8, 8),
        24
    )
    val sepCols = (sep.length * 2)
    val sideCols = ((totalCols - topicCols - sepCols).coerceAtLeast(10)) / 2
    val leftCols = sideCols
    val rightCols = sideCols

    // 스케일(좌우 독립)
    val maxL = records.maxOfOrNull { it.v1 }?.takeIf { it > 0 } ?: 1.0
    val maxR = records.maxOfOrNull { it.v2 }?.takeIf { it > 0 } ?: 1.0

    fun barLeft(v: Double): String {
        val len = (v / maxL * leftCols).roundToInt().coerceIn(0, leftCols)
        // 중앙 정렬(오른쪽 끝 맞춤)
        return " ".repeat(leftCols - len) + "=".repeat(len)
    }
    fun barRight(v: Double): String {
        val len = (v / maxR * rightCols).roundToInt().coerceIn(0, rightCols)
        // 중앙에서 오른쪽으로
        return "-".repeat(len) + " ".repeat(rightCols - len)
    }
    fun fitTopic(t: String): String =
        if (t.length <= topicCols) t.padEnd(topicCols)
        else t.take(topicCols - 1) + "…"

    return buildString {
        appendLine("======== score ========")
        appendLine(
            " ".repeat(leftCols - 2) + "v1" +
            sep + "topic".padEnd(topicCols) + sep + "v2"
        )
        records.forEach { r ->
            appendLine("${barLeft(r.v1)}$sep${fitTopic(r.topic)}$sep${barRight(r.v2)}")
        }
    }
}